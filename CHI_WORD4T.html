<!DOCTYPE html>
<html lang="zh-HK">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ä¸­è‹±é–ƒå¡ v4.5 (è½åŠ›æ¸¬é©—æ¨¡å¼)</title>
<link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700;900&family=Noto+Serif+HK:wght@500;700;900&family=Nunito:wght@600;800&display=swap" rel="stylesheet">
<style>
:root {
    --bg-primary: #e0f7fa;
    --bg-secondary: #ffffff;
    --text-primary: #37474f;
    --text-secondary: #78909c;

    --accent: #ff7043;
    --btn-speak: #42a5f5;
    --btn-record: #ef5350;
    --btn-pause: #ffca28;
    --btn-pause-text: #37474f;
    --btn-master: #66bb6a;
    --danger: #ef5350;
    --import-btn: #fdd835;
    --reset-btn: #78909c;
    --review-color: #ff9800;
    --game-bg: #e8eaf6;

    --card-border: #b2ebf2;
    --font-ui: 'M PLUS Rounded 1c', sans-serif;
    --font-learn-zh: 'Kaiti TC', 'STKaiti', 'BiaoKai', 'Noto Serif HK', serif;
    --font-learn-en: 'Nunito', sans-serif;

    --progress-color: #c8e6c9;
}

* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }

body {
    font-family: var(--font-ui);
    background: var(--bg-primary);
    color: var(--text-primary);
    height: 100vh;
    height: 100dvh;
    overflow: hidden;
    padding: 15px;
    padding-top: max(15px, env(safe-area-inset-top));
    display: flex;
    flex-direction: column;
}

/* --- å¼·åŠ›éš±è—æ–‡å­—æ¨¡å¼ CSS --- */
body.hide-text-mode .word-display {
    filter: blur(70px); opacity: 0.3;
    transition: filter 0.3s ease;
    user-select: none; pointer-events: none;
    transform: scale(0.8);
}
body.hide-text-mode .word-tag span,
body.hide-text-mode .word-tag i {
    filter: blur(15px); opacity: 0.4; pointer-events: none;
}

/* --- ä½ˆå±€ç³»çµ± --- */
.main-layout {
    display: flex; gap: 20px; height: 100%; width: 100%;
    position: relative; z-index: 10; overflow: hidden;
}

.sidebar {
    flex: 0 0 380px;
    display: flex; flex-direction: column; gap: 10px;
    height: 100%; min-height: 0;
}

/* å­¸ç”Ÿåˆ‡æ›æ¬„ */
.profile-bar {
    background: #fff; padding: 8px 12px; border-radius: 16px;
    display: flex; align-items: center; gap: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.05); border: 2px solid var(--card-border);
    flex-shrink: 0;
}
.profile-select {
    flex: 1; border: none; background: #f5f5f5; padding: 8px;
    border-radius: 8px; font-weight: bold; color: var(--text-primary);
    font-family: var(--font-ui); font-size: 1rem; outline: none;
}
.profile-btn {
    width: 36px; height: 36px; border-radius: 8px; border: none;
    background: #eceff1; color: #546e7a; font-size: 1.2rem; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
}

.learning-area {
    flex: 1; display: flex; flex-direction: column; align-items: center;
    justify-content: center; height: 100%; position: relative;
    background: rgba(255,255,255,0.3); border-radius: 24px; padding: 10px;
    min-width: 0;
}

.panel {
    background: var(--bg-secondary);
    border-radius: 16px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.05); border: 2px solid var(--card-border);
    display: flex; flex-direction: column;
    overflow: hidden;
}

.panel-header {
    padding: 8px 12px; background: #fff; z-index: 5;
    border-bottom: 1px solid #eee; flex-shrink: 0;
    display: flex; justify-content: space-between; align-items: center;
}
.panel-body {
    flex: 1; overflow-y: auto; padding: 8px;
    min-height: 0; -webkit-overflow-scrolling: touch;
}

.panel-words { flex: 3; min-height: 0; }
.panel-review { flex: 2; border-color: #ffe0b2; background-color: #fff3e0; min-height: 0; }
.panel-review .panel-header { background-color: #fff3e0; border-bottom-color: #ffe0b2; }

.panel-mastered { flex: 2; border-color: #a5d6a7; background-color: #f1f8e9; min-height: 0; }
.panel-mastered .panel-header { background-color: #f1f8e9; border-bottom-color: #dcedc8; }

.panel-title {
    font-size: 1.0rem; color: var(--text-primary); font-weight: 800;
    display: flex; justify-content: space-between; align-items: center; width: 100%;
}

.word-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(55px, 1fr));
    gap: 4px; align-content: start; width: 100%;
}

.word-tag {
    background: #f5f5f5; aspect-ratio: 1 / 1; border-radius: 12px;
    border: 2px solid transparent; cursor: pointer; position: relative;
    transition: transform 0.1s, border-color 0.2s;
    display: flex; align-items: center; justify-content: center;
    text-align: center; font-family: var(--font-learn-zh);
    color: #333; font-weight: bold; padding: 2px; overflow: hidden;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}
.word-tag:active { transform: scale(0.95); }
.word-tag.active { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(255, 112, 67, 0.3); z-index: 2; }

.has-audio-dot {
    position: absolute; top: 4px; right: 4px; width: 8px; height: 8px;
    background-color: var(--btn-record); border-radius: 50%; z-index: 3;
    box-shadow: 0 0 2px rgba(0,0,0,0.3); border: 1px solid white;
}

.word-tag-bg {
    position: absolute; bottom: 0; left: 0; width: 100%; background: var(--progress-color);
    z-index: 0; transition: height 0.5s ease; opacity: 0.6; pointer-events: none;
}

.word-tag-content { position: relative; z-index: 1; width: 100%; pointer-events: none; }
.word-tag span { line-height: 1.1; width: 100%; display: block; }

.len-1 span, .len-2 span { font-size: 1.2rem; }
.len-3 span { font-size: 0.8rem; }
.len-4 span { font-size: 0.9rem; display: flex; flex-direction: column; }
.len-4 span i { font-style: normal; width: 100%; display: block; line-height: 1.0; }
.len-long span { font-size: 0.7rem; word-break: break-word; }

.is-english { font-family: var(--font-learn-en) !important; }
.is-english.len-1 span, .is-english.len-2 span { font-size: 1.0rem; }
.is-english.len-long span { font-size: 0.6rem; }

.view-count {
    position: absolute; bottom: 1px; left: 3px; font-size: 0.55rem;
    color: #78909c; font-family: var(--font-ui); font-weight: 700; z-index: 2;
}

.add-tag {
    background: #eceff1; color: #90a4ae; font-size: 2.5rem; border: 2px dashed #cfd8dc;
}
.grid-input {
    width: 100%; height: 100%; border: none; background: #fff;
    text-align: center; font-size: 1.2rem; font-family: var(--font-learn-zh);
    outline: none; border-radius: 10px; color: var(--text-primary); padding: 0;
}

.progress-container { width: 100%; max-width: 500px; margin-bottom: 10px; text-align: center; flex-shrink: 0; }
.progress-bar { height: 8px; background: #eceff1; border-radius: 10px; overflow: hidden; }
.progress-fill { height: 100%; background: linear-gradient(90deg, #ffca28, #ffa000); transition: width 0.3s; }
.progress-text { font-size: 0.9rem; font-weight: bold; color: var(--text-secondary); margin-top: 5px; }

.flashcard {
    background: rgba(255, 255, 255, 0.95);
    width: 100%; max-width: 700px; flex: 1; max-height: 50vh;
    border-radius: 24px; border: 4px solid var(--card-border);
    box-shadow: 0 8px 0 rgba(0,0,0,0.05);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    margin-bottom: 15px; position: relative; z-index: 20;
    min-height: 150px;
}

.word-display {
    font-size: 8rem; font-weight: 700; color: var(--text-primary);
    text-align: center; line-height: 1.2; font-family: var(--font-learn-zh);
    padding: 10px; width: 100%; word-break: break-word;
}
.word-display.en-font { font-family: var(--font-learn-en); font-weight: 800; }

.status-badge {
    position: absolute; top: 15px; padding: 6px 16px; border-radius: 20px;
    font-weight: bold; font-size: 1.2rem; opacity: 0; transition: opacity 0.2s; pointer-events: none;
}
.status-waiting { background: #fff9c4; color: #f9a825; opacity: 1; border: 2px solid #fff59d; }
.status-reading { background: #e3f2fd; color: #1565c0; opacity: 1; border: 2px solid #bbdefb; }
.status-recording { background: #ffebee; color: #c62828; opacity: 1; border: 2px solid #ffcdd2; animation: pulse 1.5s infinite; }
.status-paused { background: #ffe0b2; color: #e65100; opacity: 1; border: 2px solid #ffcc80; }

@keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

.card-info-bl {
    position: absolute; bottom: 20px; left: 25px;
    font-size: 2rem; color: #90a4ae; font-weight: 800;
    display: flex; align-items: center; gap: 5px;
    text-shadow: 1px 1px 0 #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff;
}
.card-info-br {
    position: absolute; bottom: 20px; right: 25px;
    font-size: 2rem; color: #90a4ae; font-weight: 800;
    display: flex; align-items: center; gap: 5px;
    text-shadow: 1px 1px 0 #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff;
}

.controls-grid {
    display: grid; grid-template-columns: 1fr 0.4fr 1fr; gap: 20px;
    width: 100%; max-width: 600px; z-index: 20; flex-shrink: 0;
    margin-bottom: 25px;
}

.big-btn {
    border: none; padding: 14px; border-radius: 18px; font-size: 1.1rem;
    font-weight: 800; cursor: pointer; color: white;
    display: flex; align-items: center; justify-content: center; gap: 8px;
    transition: all 0.1s; position: relative; top: 0;
    font-family: var(--font-ui); box-shadow: 0 5px 0 rgba(0,0,0,0.15);
}
.big-btn:active { top: 5px; box-shadow: none !important; }
.big-btn:disabled { background: #cfd8dc !important; box-shadow: none !important; color: #fff; cursor: not-allowed; top: 0; }

.btn-speak { background: var(--btn-speak); box-shadow: 0 5px 0 #1e88e5; }
.btn-speak.paused { background: var(--btn-pause); box-shadow: 0 5px 0 #ffb300; color: var(--btn-pause-text); }

.btn-record { background: var(--btn-record); box-shadow: 0 5px 0 #c62828; font-size: 1.5rem; }
.btn-record.recording { background: #b71c1c; box-shadow: inset 0 0 10px rgba(0,0,0,0.3); top: 5px; }

.btn-master { background: var(--btn-master); box-shadow: 0 5px 0 #43a047; }

.nav-row {
    display: flex; gap: 25px; width: 100%; max-width: 600px; 
    margin-top: 20px; margin-bottom: 10px;
    justify-content: center;
}
.nav-btn {
    flex: none; width: 130px;
    background: #fff; color: var(--text-primary); border: 2px solid #cfd8dc;
    box-shadow: 0 5px 0 #b0bec5; font-size: 1rem; padding: 10px;
}

/* UI ä¿®æ”¹: åˆ†è¡Œé¡¯ç¤ºé–‹é—œ */
.toggles-area {
    margin-top: 15px;
    display: flex; flex-direction: column; gap: 10px; /* å‚ç›´æ’åˆ— */
    background: rgba(255,255,255,0.6);
    padding: 12px 20px; border-radius: 16px; flex-shrink: 0;
    align-items: center;
}
.toggle-row {
    display: flex; gap: 15px; flex-wrap: wrap; justify-content: center;
}
.toggle-item { display: flex; align-items: center; gap: 6px; font-weight: bold; font-size: 0.9rem; cursor: pointer; }
.toggle-item input { accent-color: var(--accent); width: 20px; height: 20px; }

.parents-bar {
    margin-top: auto; display: flex; gap: 10px; justify-content: center; padding-top: 10px; flex-shrink: 0;
    flex-wrap: wrap;
}
.mini-btn {
    padding: 10px 14px; font-size: 0.85rem; border-radius: 10px; border: 1px solid #cfd8dc;
    background: #fff; cursor: pointer; font-weight: bold; color: #546e7a;
}
.game-btn {
    background: #e8eaf6; color: #3f51b5; border-color: #c5cae9;
}

.save-status {
    position: fixed; bottom: 10px; right: 10px; font-size: 0.75rem;
    background: rgba(255,255,255,0.9); padding: 6px 12px; border-radius: 20px;
    color: #78909c; font-weight: bold; pointer-events: none; z-index: 1000;
    display: flex; align-items: center; gap: 6px; opacity: 0; transition: opacity 0.3s;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1); border: 1px solid #eceff1;
}

.version-tag {
    position: fixed; bottom: 5px; right: 8px; font-size: 0.65rem;
    color: #b0bec5; font-weight: bold; z-index: 5000; pointer-events: none;
    font-family: var(--font-ui);
}

/* Modal */
.custom-modal {
    display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.4);
    z-index: 3000; align-items: center; justify-content: center; backdrop-filter: blur(4px);
}
.modal-content {
    background: white; width: 90%; max-width: 500px; border-radius: 24px;
    padding: 20px; box-shadow: 0 15px 35px rgba(0,0,0,0.25);
    text-align: center; display: flex; flex-direction: column; max-height: 85vh;
    overflow-y: auto;
}

.import-textarea {
    width: 100%; height: 30vh;
    border: 2px solid #cfd8dc; border-radius: 12px;
    padding: 15px; font-size: 1.1rem; resize: none; font-family: var(--font-ui);
    margin: 10px 0;
}

.modal-actions { display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap; }
.modal-btn { flex: 1; padding: 12px; border-radius: 10px; border: none; font-weight: bold; font-size: 0.95rem; cursor: pointer; white-space: nowrap;}
.btn-save { background: var(--accent); color: white; }
.btn-paste { background: var(--import-btn); color: #333; }
.btn-no { background: #eceff1; color: #455a64; }
.btn-danger { background: var(--danger); color: white; }

/* Profile Manager Styles (Tree Structure) */
.profile-list-container {
    max-height: 50vh; overflow-y: auto; margin: 10px 0;
    border: 1px solid #eee; border-radius: 12px; padding: 5px;
}
.profile-row {
    display: flex; align-items: center; gap: 5px; padding: 8px;
    background: #f9f9f9; border-radius: 8px; margin-bottom: 6px;
    border: 1px solid #eee;
}
.profile-row.is-folder { background: #e3f2fd; border-color: #bbdefb; }
.profile-row.active-profile { border-color: var(--accent); background: #fff3e0; }

.tree-indent { width: 20px; flex-shrink: 0; display: inline-block; }

.profile-name-input {
    flex: 1; border: 1px solid transparent; background: transparent;
    font-size: 1rem; font-weight: bold; color: #333; padding: 4px;
    border-radius: 4px; font-family: var(--font-ui);
}
.profile-name-input:focus { background: #fff; border-color: var(--accent); outline: none; }

.profile-action-btn {
    width: 30px; height: 30px; border-radius: 6px; border: none;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; font-size: 0.9rem; flex-shrink: 0;
}
.btn-move { background: #eceff1; color: #546e7a; }
.btn-del { background: #ffebee; color: #c62828; }
.btn-folder { background: #e1f5fe; color: #0288d1; }

/* New Settings Grid */
.settings-grid {
    display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px;
}
.btn-setting-action {
    width: 100%; padding: 15px 5px; border-radius: 12px; border: none;
    font-weight: bold; font-size: 0.9rem; cursor: pointer; color: white;
    display: flex; flex-direction: column; align-items: center; gap: 5px;
}

.setting-row {
    display: flex; justify-content: space-between; align-items: center;
    margin-bottom: 15px; text-align: left; border-bottom: 1px solid #eee; padding-bottom: 10px;
    flex-wrap: wrap; gap: 5px;
}
.setting-label { flex: 1; padding-right: 10px; font-size: 0.95rem; font-weight: bold; color: #546e7a; min-width: 150px; }
.setting-input { width: 80px; padding: 8px; border-radius: 10px; border: 1px solid #cfd8dc; text-align: center; font-size: 1.1rem; }
.setting-input:focus { border-color: var(--accent); outline: none; background: #fff3e0; }
.setting-checkbox { width: 24px; height: 24px; accent-color: var(--accent); }

.toast {
    position: fixed;
    top: 15%; left: 50%; transform: translate(-50%, 0);
    background: rgba(0,0,0,0.85); color: white; padding: 16px 30px;
    border-radius: 40px; font-weight: bold; font-size: 1.1rem;
    z-index: 4000; opacity: 0; pointer-events: none;
    transition: opacity 0.3s; text-align: center;
    width: max-content; max-width: 90%;
}

.select-mode-active .panel-words { border-color: var(--accent); box-shadow: 0 0 0 2px var(--accent) inset; }
.delete-mode-active .panel-mastered { border-color: var(--danger); box-shadow: 0 0 0 2px var(--danger) inset; }
.review-mode-active .panel-review { border-color: #ff9800; box-shadow: 0 0 0 2px #ff9800 inset; }

.select-checkbox {
    position: absolute; top: 2px; right: 2px; width: 22px; height: 22px;
    z-index: 10; cursor: pointer;
}
.select-mode-active .word-tag, .delete-mode-active .word-tag, .review-mode-active .word-tag { cursor: default; }

.mode-controls { display: none; gap: 5px; align-items: center; flex-wrap: wrap; justify-content: flex-end; }
.mode-btn { padding: 4px 6px; border-radius: 6px; border: none; font-size: 0.65rem; font-weight: bold; cursor: pointer; color: white; margin-left: 2px; }

#confetti-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 2500; }

/* --- éŠæˆ²æ¨¡å¼ CSS --- */
.game-overlay {
    position: fixed; inset: 0; background: var(--bg-primary); z-index: 4000;
    display: none; flex-direction: column; padding: 15px; padding-top: max(15px, env(safe-area-inset-top));
}
.game-header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 10px; background: #fff; border-radius: 16px; margin-bottom: 15px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.05);
}
.game-title { font-size: 1.2rem; font-weight: 900; color: #3f51b5; display: flex; align-items: center; gap: 8px; }
.game-score { font-size: 1rem; color: #7986cb; font-weight: bold; }
.game-body { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; }
.game-grid {
    display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;
    width: 100%; max-width: 600px; height: 100%; max-height: 80vh;
    align-content: center;
}
.game-card {
    background: #fff; border-radius: 20px; border: 3px solid #e8eaf6;
    display: flex; align-items: center; justify-content: center;
    font-family: var(--font-learn-zh); font-weight: bold; color: #333;
    font-size: 2rem; cursor: pointer; box-shadow: 0 4px 0 #c5cae9;
    transition: transform 0.1s, background 0.2s; position: relative;
    aspect-ratio: 2 / 1;
}
.game-card:active { transform: scale(0.95); box-shadow: 0 2px 0 #c5cae9; top: 2px; }
.game-card.shake { animation: shake 0.5s; border-color: #ef5350; background: #ffebee; }
.game-card.correct { border-color: #66bb6a; background: #e8f5e9; transform: scale(1.05); z-index: 10; }
.game-card.is-english { font-family: var(--font-learn-en); font-size: 1.5rem; }

.game-controls {
    margin-top: 20px; display: flex; gap: 20px; justify-content: center; width: 100%;
}
.btn-replay {
    width: 60px; height: 60px; border-radius: 50%; border: none;
    background: #3f51b5; color: white; font-size: 1.5rem;
    box-shadow: 0 4px 10px rgba(63, 81, 181, 0.3); cursor: pointer;
    display: flex; align-items: center; justify-content: center;
}
.btn-replay:active { transform: scale(0.9); }

@keyframes shake {
    0% { transform: translateX(0); } 25% { transform: translateX(-5px); }
    50% { transform: translateX(5px); } 75% { transform: translateX(-5px); } 100% { transform: translateX(0); }
}

@media (orientation: portrait) {
    .main-layout { flex-direction: column; gap: 10px; }
    .sidebar { flex: none; height: 50%; width: 100%; }
    .learning-area { height: 50%; border-radius: 24px 24px 0 0; }
    .word-grid { grid-template-columns: repeat(auto-fill, minmax(45px, 1fr)); }
    .flashcard { max-height: 30vh; }
    .word-display { font-size: 6rem; }
    .controls-grid { margin-bottom: 20px; }
    .card-info-bl, .card-info-br { font-size: 1.5rem; bottom: 10px; }
    .game-grid { grid-template-columns: repeat(2, 1fr); gap: 10px; }
    .game-card { font-size: 1.8rem; }
}

@media (max-width: 600px) {
    .word-display { font-size: 4rem; }
    .big-btn { font-size: 0.9rem; padding: 10px; }
    .sidebar { height: 45%; }
    .learning-area { height: 55%; }
}
</style>
</head>
<body>

    <canvas id="confetti-canvas"></canvas>
    <div class="version-tag">v4.5</div>

    <div class="main-layout">
        <div class="sidebar">
            <div class="profile-bar">
                <span style="font-size:1.2rem">ğŸ‘¤</span>
                <select id="profileSelect" class="profile-select" onchange="switchProfile(this.value)">
                    <option value="default">é è¨­å­¸ç”Ÿ</option>
                </select>
                <button class="profile-btn" onclick="openProfileManager()">âš™ï¸</button>
            </div>

            <div class="panel panel-words">
                <div class="panel-header">
                    <div class="panel-title">
                        <span>ğŸ“– è©èªè¡¨ <small id="wordCount">(0)</small></span>
                        <div id="wordSelectControls" class="mode-controls">
                            <button class="mode-btn" style="background:#78909c" onclick="toggleSelectAll('#wordList')">å…¨é¸</button>
                            <button class="mode-btn" style="background:var(--review-color)" onclick="confirmBatchMoveFromWordsToReview()">ç§»è‡³é‚„è¦ç·´</button>
                            <button class="mode-btn" style="background:var(--btn-master)" onclick="confirmBatchMove()">ç§»è‡³å·²å­¸è­˜</button>
                            <button class="mode-btn" style="background:var(--danger)" onclick="confirmBatchDeleteFromWords()">åˆªé™¤</button>
                            <button class="mode-btn" style="background:#cfd8dc; color:#555" onclick="exitWordSelectMode()">å–æ¶ˆ</button>
                        </div>
                    </div>
                </div>
                <div class="panel-body">
                    <div class="word-grid" id="wordList"></div>
                </div>
            </div>

            <div class="panel panel-review">
                <div class="panel-header">
                    <div class="panel-title">
                        <span>ğŸ’ª é‚„è¦ç·´ <small id="reviewCount">(0)</small></span>
                        <div id="reviewControls" class="mode-controls">
                            <button class="mode-btn" style="background:#78909c" onclick="toggleSelectAll('#reviewList')">å…¨é¸</button>
                            <button class="mode-btn" style="background:var(--btn-speak)" onclick="confirmBatchMoveFromReviewToWords()">é€€å›è©èªè¡¨</button>
                            <button class="mode-btn" style="background:var(--btn-master)" onclick="confirmBatchMoveFromReviewToMastered()">æ™‰ç´šå·²å­¸è­˜</button>
                            <button class="mode-btn" style="background:#cfd8dc; color:#555" onclick="exitReviewMode()">å–æ¶ˆ</button>
                        </div>
                    </div>
                </div>
                <div class="panel-body">
                    <div class="word-grid" id="reviewList"></div>
                </div>
            </div>

            <div class="panel panel-mastered">
                <div class="panel-header">
                    <div class="panel-title">
                        <span>ğŸ† å·²å­¸è­˜ <small id="masteredCount">(0)</small></span>
                        <div id="deleteControls" class="mode-controls">
                            <button class="mode-btn" style="background:#78909c" onclick="toggleSelectAll('#masteredList')">å…¨é¸</button>
                            <button class="mode-btn" style="background:var(--btn-speak)" onclick="confirmBatchRestore()">é‚„åŸè©èªè¡¨</button>
                            <button class="mode-btn" style="background:var(--review-color)" onclick="confirmBatchMoveFromMasteredToReview()">ç§»è‡³é‚„è¦ç·´</button>
                            <button class="mode-btn" style="background:var(--danger)" onclick="confirmBatchDelete()">åˆªé™¤</button>
                            <button class="mode-btn" style="background:#cfd8dc; color:#555" onclick="exitDeleteMode()">å–æ¶ˆ</button>
                        </div>
                    </div>
                </div>
                <div class="panel-body">
                    <div class="word-grid" id="masteredList"></div>
                    <div style="text-align:center; font-size:0.75rem; color:#90a4ae; margin-top:8px;">(é•·æŒ‰ç®¡ç†)</div>
                </div>
            </div>

            <div class="parents-bar">
                <button class="mini-btn game-btn" onclick="openGameMode()">ğŸ® è½åŠ›æ¸¬é©—</button>
                <button class="mini-btn" onclick="openEditModal()">ğŸ“ ç·¨è¼¯/å°å…¥</button>
                <button class="mini-btn" onclick="exportData()">ğŸ“¤ å°å‡º</button>
                <button class="mini-btn" onclick="openSettingsModal()">âš™ï¸ è¨­å®š</button>
            </div>
        </div>

        <div class="learning-area">
            <div class="progress-container">
                <div class="progress-bar"><div id="progressFill" class="progress-fill" style="width: 0%"></div></div>
                <div class="progress-text" id="progressText">æº–å‚™é–‹å§‹</div>
            </div>

            <div class="flashcard" id="flashcard">
                <div class="status-badge" id="statusBadge">ğŸ‘€ æº–å‚™</div>
                <div class="word-display" id="currentWord">...</div>
                <div class="card-info-bl" id="cardViewCount">ğŸ‘‚ 0</div>
                <div class="card-info-br" id="cardMasteryProgress">ğŸ¯ 0/2</div>
            </div>

            <div class="controls-grid">
                <button class="big-btn btn-master" id="masteredBtn" onclick="handleMasteryClick(event)">âœ… æˆ‘è­˜è®€!</button>
                <button class="big-btn btn-record" id="recordBtn">ğŸ¤</button>
                <button class="big-btn btn-speak" id="speakBtn" onclick="toggleSpeak()">ğŸ”Š æœ—è®€</button>
            </div>

            <div class="nav-row">
                <button class="big-btn nav-btn" id="prevBtn" onclick="manualPrev()">ğŸ‘ˆ ä¸Šä¸€å€‹</button>
                <button class="big-btn nav-btn" id="nextBtn" onclick="manualNext()">ä¸‹ä¸€å€‹ ğŸ‘‰</button>
            </div>

            <div class="toggles-area">
                <div class="toggle-row">
                    <label class="toggle-item"><input type="checkbox" id="readImmediatelyToggle"> âš¡ ç«‹å³æœ—è®€</label>
                    <label class="toggle-item"><input type="checkbox" id="autoPlayNext"> â–¶ï¸ è‡ªå‹•æ¨¡å¼</label>
                    <label class="toggle-item"><input type="checkbox" id="repeatThreeTimes"> ğŸ” è®€ä¸‰æ¬¡</label>
                </div>
                <div class="toggle-row">
                    <label class="toggle-item"><input type="checkbox" id="randomOrder"> ğŸ”€ æ´—ç‰Œæ¨¡å¼</label>
                    <label class="toggle-item"><input type="checkbox" id="hideTextMode"> ğŸ™ˆ éš±è—æ–‡å­—</label>
                </div>
            </div>
        </div>
    </div>

    <!-- éŠæˆ²æ¨¡å¼ Overlay -->
    <div id="gameOverlay" class="game-overlay">
        <div class="game-header">
            <div class="game-title">ğŸ® è½åŠ›æ¸¬é©— <small style="font-size:0.8rem; color:#7986cb; margin-left:5px;">(é‚„è¦ç·´å„ªå…ˆ)</small></div>
            <button class="mini-btn" onclick="closeGameMode()">âŒ é›¢é–‹</button>
        </div>
        <div class="game-body">
            <div class="game-grid" id="gameGrid">
                <!-- Cards will be generated here -->
            </div>
            <div class="game-controls">
                <button class="btn-replay" onclick="playGameAudio()">ğŸ”Š</button>
            </div>
        </div>
    </div>

    <div id="saveStatus" class="save-status">â˜ï¸ æº–å‚™ä¸­...</div>
    <div id="toast" class="toast">æç¤ºè¨Šæ¯</div>

    <!-- å­¸ç”Ÿç®¡ç†è¦–çª— -->
    <div id="profileManagerModal" class="custom-modal">
        <div class="modal-content">
            <div class="modal-title">ğŸ‘¤ å­¸ç”Ÿèˆ‡ç›®éŒ„ç®¡ç†</div>
            <p style="font-size:0.85rem; color:#888; margin-bottom:10px;">å»ºç«‹è³‡æ–™å¤¾åˆ†é¡ï¼Œæˆ–ç›´æ¥ç®¡ç†å­¸ç”Ÿ</p>
            <div id="profileListContainer" class="profile-list-container"></div>
            <div class="modal-actions" style="margin-top:5px;">
                <button class="modal-btn btn-folder" onclick="openAddFolderModal()">ğŸ“ æ–°å¢ç›®éŒ„</button>
                <button class="modal-btn btn-save" onclick="openAddProfileModal()">â• æ–°å¢å­¸ç”Ÿ</button>
                <button class="modal-btn btn-no" onclick="closeModal('profileManagerModal')">å®Œæˆ</button>
            </div>
        </div>
    </div>

    <!-- æ–°å¢å­¸ç”Ÿ/ç›®éŒ„è¦–çª— -->
    <div id="addProfileModal" class="custom-modal" style="z-index: 3100;">
        <div class="modal-content">
            <div class="modal-title" id="addModalTitle">â• æ–°å¢å­¸ç”Ÿ</div>
            <input type="text" id="newProfileNameInput" class="import-textarea" style="height:50px; text-align:center;" placeholder="è¼¸å…¥åå­—">
            <div style="margin-top:10px; text-align:left;">
                <label style="font-size:0.85rem; color:#666; font-weight:bold;">ä½ç½® (çˆ¶ç›®éŒ„):</label>
                <select id="parentFolderSelect" class="profile-select" style="width:100%; margin-top:5px;">
                    <option value="">(æ ¹ç›®éŒ„)</option>
                </select>
            </div>
            <div class="modal-actions">
                <button class="modal-btn btn-save" onclick="confirmAddProfileOrFolder()">å»ºç«‹</button>
                <button class="modal-btn btn-no" onclick="closeModal('addProfileModal')">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- ç·¨è¼¯è¦–çª— -->
    <div id="importModal" class="custom-modal">
        <div class="modal-content">
            <div class="modal-title">ğŸ“ ç·¨è¼¯/å°å…¥</div>
            <p style="font-size:0.9rem; color:#666; margin-bottom:5px;">ç›´æ¥ä¿®æ”¹æˆ–ç”±å‰ªè²¼ç°¿å°å…¥ã€‚</p>
            <textarea id="importTextarea" class="import-textarea"></textarea>
            <div class="modal-actions">
                <button class="modal-btn btn-paste" onclick="selectAllImportText()">âœ¨ å…¨é¸ (æ–¹ä¾¿è²¼ä¸Š)</button>
                <button class="modal-btn btn-save" onclick="saveEdit()">ğŸ’¾ ä¿å­˜</button>
                <button class="modal-btn btn-no" onclick="closeModal('importModal')">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- è¨­å®šè¦–çª— -->
    <div id="settingsModal" class="custom-modal">
        <div class="modal-content">
            <div class="modal-title">âš™ï¸ è¨­å®š</div>
            <div class="setting-row">
                <div class="setting-label">è‡ªå‹•æ¨¡å¼å€’æ•¸ (ç§’)</div>
                <input type="number" id="settingAutoDelay" class="setting-input" value="4" min="1" max="10" onchange="autoSaveSettings()">
            </div>
            <div class="setting-row">
                <div class="setting-label">é‡è¤‡æœ—è®€é–“éš” (ç§’)</div>
                <input type="number" id="settingRepeatDelay" class="setting-input" value="3" min="1" max="5" onchange="autoSaveSettings()">
            </div>
            <div class="setting-row">
                <div class="setting-label">ã€Œæˆ‘è­˜è®€ã€é–€æª» (æ¬¡)</div>
                <input type="number" id="settingMasteryThreshold" class="setting-input" value="2" min="1" max="20" onchange="autoSaveSettings()">
            </div>
            <div class="setting-row">
                <div class="setting-label">ã€Œç†Ÿç·´åº¦åˆ¤æ–·ã€è½è®€æ¬¡æ•¸ä¸Šé™</div>
                <input type="number" id="settingMasteryViewLimit" class="setting-input" value="1" min="1" max="50" onchange="autoSaveSettings()">
            </div>

            <div class="settings-grid">
                <button class="btn-setting-action" style="background:#5c6bc0;" onclick="confirmAction('resetStats')">
                    <span>ğŸ“Š é‡ç½®çµ±è¨ˆ</span><span style="font-size:0.7rem; opacity:0.8; font-weight:normal">è½è®€æ¬¡æ•¸æ­¸é›¶</span>
                </button>
                <button class="btn-setting-action" style="background:#78909c;" onclick="confirmAction('resetSettings')">
                    <span>â†©ï¸ é‚„åŸè¨­å®š</span><span style="font-size:0.7rem; opacity:0.8; font-weight:normal">åˆå§‹å€¼ (4, 3, 2, 1)</span>
                </button>
                <button class="btn-setting-action" style="background:#ff9800;" onclick="confirmAction('clearAudio')">
                    <span>ğŸ—‘ï¸ æ¸…é™¤éŒ„éŸ³</span><span style="font-size:0.7rem; opacity:0.8; font-weight:normal">ä¿ç•™æ–‡å­—ï¼Œåˆªè²éŸ³</span>
                </button>
                <button class="btn-setting-action" style="background:var(--danger);" onclick="confirmAction('clearAll')">
                    <span>ğŸ’¥ æ¸…ç©ºæ‰€æœ‰</span><span style="font-size:0.7rem; opacity:0.8; font-weight:normal">åˆªé™¤å…¨éƒ¨è³‡æ–™</span>
                </button>
            </div>
            <div class="modal-actions" style="margin-top: 20px;">
                <button class="modal-btn btn-no" onclick="closeModal('settingsModal')">é—œé–‰</button>
            </div>
        </div>
    </div>

    <!-- é€šç”¨ç¢ºèªè¦–çª— -->
    <div id="confirmModal" class="custom-modal" style="z-index: 3500;">
        <div class="modal-content" style="max-width: 350px;">
            <div class="modal-title" style="font-size: 1.2rem; margin-bottom: 10px;">âš ï¸ ç¢ºèªæ“ä½œ</div>
            <p id="confirmMessage" style="color: #555; margin-bottom: 20px;">ç¢ºå®šè¦åŸ·è¡Œå—ï¼Ÿ</p>
            <div class="modal-actions">
                <button id="confirmBtn" class="modal-btn btn-save" style="margin-top:0">ç¢ºå®š</button>
                <button class="modal-btn btn-no" onclick="closeModal('confirmModal')">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <script>
        // --- å…¨å±€è®Šæ•¸ ---
        let words = [];
        let reviewWords = [];
        let masteredWords = [];
        const FALLBACK_WORDS = ["å­¸æ ¡", "æœ‹å‹", "å¿«æ¨‚", "è€å¸«", "çˆ¸çˆ¸", "åª½åª½", "å…¬åœ’", "è®€æ›¸", "å¯«å­—", "éŠæˆ²", "å¤ªé™½", "æœˆäº®", "æ˜Ÿæ˜Ÿ", "å¤©ç©º", "èŠ±æœµ", "å°ç‹—", "å°è²“", "åƒé£¯", "å–æ°´", "ç¡è¦º"];
        
        let profiles = JSON.parse(localStorage.getItem('flashcard_profiles')) || [{id: 'default', name: 'é è¨­å­¸ç”Ÿ', parentId: null, isFolder: false}];
        let currentProfileId = localStorage.getItem('flashcard_current_profile') || 'default';

        profiles.forEach(p => {
            if(p.parentId === undefined) p.parentId = null;
            if(p.isFolder === undefined) p.isFolder = false;
        });

        const initialWords = ["éƒ½æ˜¯", "Apple", "é€™å€‹", "Banana", "åˆæˆ", "Orange", "å…±æœ‰"];
        const initialReview = [];
        const initialMastered = ["å’Œ", "é«˜", "Cat"];

        let currentIndex = 0;
        let cantoneseVoice = null;
        let englishVoice = null;
        let availableVoices = [];

        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let recordingTimerInterval = null;
        let recordingSeconds = 0;
        let globalAudioPlayer = new Audio();

        let state = { status: 'idle', timerId: null, watchdogId: null, countdownRemaining: 0, countdownCallback: null, countdownLabel: '', repeatCount: 0 };
        let currentRoundId = 1;

        let isDeleteMode = false;
        let isWordSelectMode = false;
        let isReviewMode = false;

        let settings = { autoDelay: 4, repeatDelay: 3, masteryThreshold: 2, masteryViewLimit: 1, readImmediately: false };

        const DB_NAME = 'FlashcardDB_v4.0';
        const DB_VERSION = 1;
        let db = null;
        let isDirty = false;
        let saveTimeout = null;
        let mediaUnlocked = false;

        let isAddingFolder = false;

        // --- Game Mode Variables ---
        let gameTarget = null;
        let gameItems = [];
        let isGameActive = false;

        // --- è¼”åŠ©å‡½æ•¸ ---
        function getDBKey(type) {
            return `${currentProfileId}_${type}`;
        }

        function buildFolderOptions(parentId, depth, excludeId = null) {
            const children = profiles.filter(p => p.parentId === parentId && p.isFolder && p.id !== excludeId);
            let html = '';
            children.forEach(p => {
                const indent = "&nbsp;&nbsp;".repeat(depth);
                const icon = "ğŸ“ ";
                html += `<option value="${p.id}">${indent}${icon}${p.name}</option>`;
                html += buildFolderOptions(p.id, depth + 1, excludeId);
            });
            return html;
        }

        function updateProfileSelectUI() {
            const select = document.getElementById('profileSelect');
            select.innerHTML = '';
            function renderTreeOptions(pid, depth) {
                const items = profiles.filter(p => p.parentId === pid);
                items.sort((a,b) => (a.isFolder === b.isFolder) ? 0 : a.isFolder ? -1 : 1);
                items.forEach(item => {
                    if(item.isFolder) {
                        const opt = document.createElement('option');
                        opt.disabled = true;
                        opt.innerHTML = "&nbsp;&nbsp;".repeat(depth) + "ğŸ“ " + item.name;
                        select.appendChild(opt);
                        renderTreeOptions(item.id, depth + 1);
                    } else {
                        const opt = document.createElement('option');
                        opt.value = item.id;
                        opt.innerHTML = "&nbsp;&nbsp;".repeat(depth) + (depth>0?"â”” ":"") + item.name;
                        if(item.id === currentProfileId) opt.selected = true;
                        select.appendChild(opt);
                    }
                });
            }
            renderTreeOptions(null, 0);
        }

        function openProfileManager() {
            renderProfileManagerList();
            document.getElementById('profileManagerModal').style.display = 'flex';
        }

        function renderProfileManagerList() {
            const container = document.getElementById('profileListContainer');
            container.innerHTML = '';
            function renderNode(pid, depth) {
                const items = profiles.filter(p => p.parentId === pid);
                items.sort((a,b) => (a.isFolder === b.isFolder) ? 0 : a.isFolder ? -1 : 1);
                items.forEach(p => {
                    const row = document.createElement('div');
                    row.className = 'profile-row';
                    if(p.isFolder) row.classList.add('is-folder');
                    if(p.id === currentProfileId) row.classList.add('active-profile');
                    for(let i=0; i<depth; i++) {
                        const indent = document.createElement('span');
                        indent.className = 'tree-indent';
                        row.appendChild(indent);
                    }
                    const icon = document.createElement('span');
                    icon.style.marginRight = '5px';
                    icon.textContent = p.isFolder ? 'ğŸ“' : 'ğŸ‘¤';
                    row.appendChild(icon);
                    const input = document.createElement('input');
                    input.className = 'profile-name-input';
                    input.value = p.name;
                    input.onchange = (e) => renameProfile(p.id, e.target.value);
                    row.appendChild(input);
                    const editBtn = document.createElement('button');
                    editBtn.className = 'profile-action-btn btn-move';
                    editBtn.innerHTML = 'âœï¸';
                    editBtn.onclick = () => openEditProfileModal(p.id);
                    row.appendChild(editBtn);
                    const delBtn = document.createElement('button');
                    delBtn.className = 'profile-action-btn btn-del';
                    delBtn.innerHTML = 'âŒ';
                    delBtn.onclick = () => deleteProfileSpecific(p.id);
                    row.appendChild(delBtn);
                    container.appendChild(row);
                    if(p.isFolder) renderNode(p.id, depth + 1);
                });
            }
            renderNode(null, 0);
        }

        function renameProfile(id, newName) {
            const p = profiles.find(x => x.id === id);
            if(p && newName.trim()) {
                p.name = newName.trim();
                saveProfiles();
                updateProfileSelectUI();
            } else {
                renderProfileManagerList();
            }
        }

        function deleteProfileSpecific(id) {
            const p = profiles.find(x => x.id === id);
            if(p.isFolder) {
                const hasChildren = profiles.some(child => child.parentId === id);
                if(hasChildren) { showToast("ç›®éŒ„ä¸ç‚ºç©ºï¼Œç„¡æ³•åˆªé™¤"); return; }
            } else {
                if(profiles.filter(x => !x.isFolder).length <= 1) { showToast("æœ€å°‘è¦ä¿ç•™ä¸€å€‹å­¸ç”Ÿ"); return; }
            }
            if(!confirm(`ç¢ºå®šè¦åˆªé™¤ã€Œ${p.name}ã€å—ï¼Ÿ`)) return;
            const isCurrent = (p.id === currentProfileId);
            const idx = profiles.findIndex(x => x.id === id);
            profiles.splice(idx, 1);
            saveProfiles();
            if(isCurrent) {
                const next = profiles.find(x => !x.isFolder);
                if(next) switchProfile(next.id);
            } else {
                updateProfileSelectUI();
            }
            renderProfileManagerList();
            showToast("å·²åˆªé™¤");
        }

        function saveProfiles() {
            localStorage.setItem('flashcard_profiles', JSON.stringify(profiles));
        }

        let editingProfileId = null;
        function openAddProfileModal() {
            isAddingFolder = false; editingProfileId = null;
            document.getElementById('addModalTitle').textContent = "â• æ–°å¢å­¸ç”Ÿ";
            document.getElementById('newProfileNameInput').value = '';
            updateParentFolderSelect(null);
            document.getElementById('addProfileModal').style.display = 'flex';
            document.getElementById('newProfileNameInput').focus();
        }

        function openAddFolderModal() {
            isAddingFolder = true; editingProfileId = null;
            document.getElementById('addModalTitle').textContent = "ğŸ“ æ–°å¢ç›®éŒ„";
            document.getElementById('newProfileNameInput').value = '';
            updateParentFolderSelect(null);
            document.getElementById('addProfileModal').style.display = 'flex';
            document.getElementById('newProfileNameInput').focus();
        }

        function openEditProfileModal(id) {
            const p = profiles.find(x => x.id === id);
            if(!p) return;
            editingProfileId = id; isAddingFolder = p.isFolder;
            document.getElementById('addModalTitle').textContent = p.isFolder ? "âœï¸ ç·¨è¼¯ç›®éŒ„" : "âœï¸ ç·¨è¼¯å­¸ç”Ÿ";
            document.getElementById('newProfileNameInput').value = p.name;
            updateParentFolderSelect(p.parentId, p.id);
            document.getElementById('addProfileModal').style.display = 'flex';
        }

        function updateParentFolderSelect(selectedId, excludeId = null) {
            const sel = document.getElementById('parentFolderSelect');
            sel.innerHTML = '<option value="">(æ ¹ç›®éŒ„)</option>' + buildFolderOptions(null, 0, excludeId);
            if(selectedId) sel.value = selectedId; else sel.value = "";
        }

        function confirmAddProfileOrFolder() {
            const name = document.getElementById('newProfileNameInput').value.trim();
            const parentId = document.getElementById('parentFolderSelect').value || null;
            if(!name) return;
            if(editingProfileId) {
                const p = profiles.find(x => x.id === editingProfileId);
                if(p) {
                    p.name = name; p.parentId = parentId;
                    saveProfiles(); updateProfileSelectUI(); renderProfileManagerList(); showToast("å·²æ›´æ–°");
                }
            } else {
                const id = (isAddingFolder ? 'folder_' : 'student_') + Date.now();
                profiles.push({ id: id, name: name, parentId: parentId, isFolder: isAddingFolder });
                saveProfiles();
                if(!isAddingFolder) switchProfile(id);
                updateProfileSelectUI(); renderProfileManagerList(); showToast(isAddingFolder ? "å·²å»ºç«‹ç›®éŒ„" : "å·²å»ºç«‹å­¸ç”Ÿ");
            }
            closeModal('addProfileModal');
        }

        async function switchProfile(newId) {
            if(newId === currentProfileId) return;
            if(isDirty) { await new Promise(resolve => { saveDataToDB(); setTimeout(resolve, 500); }); }
            currentProfileId = newId;
            localStorage.setItem('flashcard_current_profile', currentProfileId);
            words = []; reviewWords = []; masteredWords = [];
            currentIndex = 0; currentRoundId = 1;
            stopEverything();
            await loadDataFromDB();
            updateProfileSelectUI(); renderLists(); updateCard();
            if(document.getElementById('profileManagerModal').style.display === 'flex') renderProfileManagerList();
            showToast("å·²åˆ‡æ›å­¸ç”Ÿæª”æ¡ˆ");
        }

        function toggleSelectAll(selector) {
            const checkboxes = document.querySelectorAll(`${selector} .select-checkbox`);
            if(checkboxes.length === 0) return;
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            checkboxes.forEach(cb => cb.checked = !allChecked);
        }

        function makeSilentWavBlob(durationMs = 120, sampleRate = 44100) {
            const numSamples = Math.floor(sampleRate * (durationMs / 1000));
            const buffer = new ArrayBuffer(44 + numSamples * 2);
            const view = new DataView(buffer);
            const writeString = (o, s) => { for (let i=0; i<s.length; i++) view.setUint8(o+i, s.charCodeAt(i)); };
            writeString(0, 'RIFF'); view.setUint32(4, 36 + numSamples*2, true); writeString(8, 'WAVE');
            writeString(12, 'fmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true);
            view.setUint16(22, 1, true); view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate*2, true);
            view.setUint16(32, 2, true); view.setUint16(34, 16, true); writeString(36, 'data');
            view.setUint32(40, numSamples*2, true);
            return new Blob([buffer], { type: 'audio/wav' });
        }

        async function unlockAudioAndSpeech() {
            if (mediaUnlocked) return;
            try {
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel();
                    const u = new SpeechSynthesisUtterance(' '); u.volume = 0;
                    window.speechSynthesis.speak(u);
                }
                const silent = makeSilentWavBlob(120);
                const url = URL.createObjectURL(silent);
                globalAudioPlayer.muted = true; globalAudioPlayer.src = url;
                await globalAudioPlayer.play().catch(() => {});
                globalAudioPlayer.pause(); globalAudioPlayer.muted = false;
                URL.revokeObjectURL(url);
                mediaUnlocked = true;
            } catch (e) { console.warn('Unlock failed', e); }
        }

        function initGestureUnlock() {
            const handler = async () => {
                await unlockAudioAndSpeech();
                document.removeEventListener('touchstart', handler);
                document.removeEventListener('mousedown', handler);
                document.removeEventListener('keydown', handler);
            };
            document.addEventListener('touchstart', handler, { passive: true });
            document.addEventListener('mousedown', handler);
            document.addEventListener('keydown', handler);
        }

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = () => reject("DB_OPEN_FAIL");
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('data')) db.createObjectStore('data', { keyPath: 'id' });
                };
                request.onsuccess = (event) => { db = event.target.result; resolve(db); };
            });
        }

        async function loadDataFromDB() {
            if (!db) return false;
            return new Promise((resolve) => {
                const transaction = db.transaction(['data'], 'readonly');
                const store = transaction.objectStore('data');
                let keyPrefix = currentProfileId === 'default' ? '' : (currentProfileId + '_');
                
                const getWords = store.get(getDBKey('words'));
                const getReview = store.get(getDBKey('review'));
                const getMastered = store.get(getDBKey('mastered'));
                const getSettings = store.get(getDBKey('settings'));
                
                const getOldWords = store.get('words');
                const getOldReview = store.get('review');
                const getOldMastered = store.get('mastered');
                const getOldSettings = store.get('settings');

                transaction.oncomplete = () => {
                    if (getWords.result) words = getWords.result.value;
                    else if (currentProfileId === 'default' && getOldWords.result) words = getOldWords.result.value;
                    else words = (currentProfileId === 'default') ? [...initialWords].map(w => ({ text: w, views: 0, hits: 0, audioBlob: null, roundId: 0 })) : [];

                    if (getReview.result) reviewWords = getReview.result.value;
                    else if (currentProfileId === 'default' && getOldReview.result) reviewWords = getOldReview.result.value;
                    else reviewWords = (currentProfileId === 'default') ? [...initialReview].map(w => ({ text: w, views: 0, hits: 0, audioBlob: null, roundId: 0 })) : [];

                    if (getMastered.result) masteredWords = getMastered.result.value;
                    else if (currentProfileId === 'default' && getOldMastered.result) masteredWords = getOldMastered.result.value;
                    else masteredWords = (currentProfileId === 'default') ? [...initialMastered].map(w => ({ text: w, views: 0, hits: 0, audioBlob: null, roundId: 0 })) : [];

                    if (getSettings.result) settings = { ...settings, ...getSettings.result.value };
                    else if (currentProfileId === 'default' && getOldSettings.result) settings = { ...settings, ...getOldSettings.result.value };

                    words.forEach(w => { if (typeof w.roundId !== 'number') w.roundId = 0; });
                    resolve(true);
                };
                transaction.onerror = () => resolve(false);
            });
        }

        function saveDataToDB() {
            if (!db || !isDirty) return;
            if (saveTimeout) clearTimeout(saveTimeout);
            updateSaveStatus('saving');
            saveTimeout = setTimeout(() => {
                try {
                    const transaction = db.transaction(['data'], 'readwrite');
                    const store = transaction.objectStore('data');
                    store.put({ id: getDBKey('words'), value: words });
                    store.put({ id: getDBKey('review'), value: reviewWords });
                    store.put({ id: getDBKey('mastered'), value: masteredWords });
                    store.put({ id: getDBKey('settings'), value: settings });
                    if (currentProfileId === 'default') {
                        store.put({ id: 'words', value: words });
                        store.put({ id: 'review', value: reviewWords });
                        store.put({ id: 'mastered', value: masteredWords });
                        store.put({ id: 'settings', value: settings });
                    }
                    transaction.oncomplete = () => { updateSaveStatus('saved'); isDirty = false; };
                    transaction.onerror = () => updateSaveStatus('error');
                } catch (e) { updateSaveStatus('error'); }
            }, 1000);
        }

        function updateSaveStatus(status) {
            const el = document.getElementById('saveStatus');
            el.style.opacity = 1;
            if (status === 'saving') { el.textContent = 'ğŸ’¾ å„²å­˜ä¸­...'; el.style.color = '#ffa000'; }
            else if (status === 'saved') {
                el.textContent = 'â˜ï¸ å·²å„²å­˜'; el.style.color = '#4caf50';
                setTimeout(() => { if(!isDirty) el.style.opacity = 0; }, 2000);
            }
            else if (status === 'error') { el.textContent = 'âš ï¸ ç„¡æ³•å„²å­˜'; el.style.color = '#f44336'; }
        }

        function markDirty() { isDirty = true; updateSaveStatus('saving'); saveDataToDB(); }

        async function init() {
            initGestureUnlock();
            updateProfileSelectUI(); 
            try {
                await initDB();
                await loadDataFromDB();
                updateSaveStatus('saved');
            } catch (e) {
                console.warn("DB Init failed", e);
                words = initialWords.map(w => ({ text: w, views: 0, hits: 0, audioBlob: null, roundId: 0 }));
                updateSaveStatus('error');
            }
            renderLists();
            updateCard();
            if ('speechSynthesis' in window) {
                window.speechSynthesis.onvoiceschanged = loadVoices;
                loadVoices();
            }
            
            const readImmToggle = document.getElementById('readImmediatelyToggle');
            readImmToggle.checked = settings.readImmediately;
            readImmToggle.addEventListener('change', (e) => {
                settings.readImmediately = e.target.checked;
                autoSaveSettings();
            });

            document.getElementById('autoPlayNext').addEventListener('change', async (e) => {
                stopEverything();
                if (!e.target.checked) return;
                await unlockAudioAndSpeech();
                if (words.length > 0) {
                    if (document.getElementById('randomOrder').checked) { currentIndex = pickNextIndexRandom(true); updateCard(); }
                    startSequence();
                }
            });
            document.getElementById('randomOrder').addEventListener('change', () => {
                currentRoundId++; words.forEach(w => w.roundId = 0);
                if (document.getElementById('randomOrder').checked && words.length > 0) currentIndex = pickNextIndexRandom(true);
                updateCard();
            });
            document.getElementById('hideTextMode').addEventListener('change', (e) => {
                if(e.target.checked) document.body.classList.add('hide-text-mode');
                else document.body.classList.remove('hide-text-mode');
            });
            const recBtn = document.getElementById('recordBtn');
            const handleRecStart = (e) => { e.preventDefault(); startRecording(); };
            const handleRecStop = (e) => { e.preventDefault(); stopRecording(); };
            recBtn.addEventListener('mousedown', handleRecStart); recBtn.addEventListener('mouseup', handleRecStop);
            recBtn.addEventListener('touchstart', handleRecStart); recBtn.addEventListener('touchend', handleRecStop);
            window.onbeforeunload = function () { if (isDirty) return "æ‚¨æœ‰æœªå„²å­˜çš„è®Šæ›´"; };
        }

        function loadVoices() {
            availableVoices = window.speechSynthesis.getVoices();
            if (availableVoices.length === 0) return;
            cantoneseVoice = availableVoices.find(v => v.lang === 'zh-HK' && v.name.includes('Google')) || availableVoices.find(v => v.lang === 'zh-HK');
            englishVoice = availableVoices.find(v => v.name.includes('Moira')) || availableVoices.find(v => v.lang.startsWith('en'));
        }

        function isEnglish(text) { return /^[A-Za-z0-9\s\.,\?!'"]+$/.test(text); }

        function pickNextIndexRandom(allowSameAsCurrent = false) {
            if (words.length === 0) return 0;
            let candidates = [];
            for (let i = 0; i < words.length; i++) {
                if (words[i].roundId !== currentRoundId) candidates.push(i);
            }
            if (candidates.length === 0) {
                currentRoundId++;
                candidates = words.map((_, i) => i);
            }
            if (!allowSameAsCurrent && words.length > 1) {
                candidates = candidates.filter(i => i !== currentIndex);
                if (candidates.length === 0) candidates = [currentIndex];
            }
            const idx = candidates[Math.floor(Math.random() * candidates.length)];
            words[idx].roundId = currentRoundId;
            return idx;
        }

        function startAutoIfEnabled() { if (document.getElementById('autoPlayNext').checked) startSequence(); }

        function advanceNextForAuto() {
            if (words.length === 0) return;
            if (document.getElementById('randomOrder').checked) currentIndex = pickNextIndexRandom(false);
            else currentIndex = (currentIndex + 1) % words.length;
            updateCard();
            startSequence(); 
        }

        function playCardAudioWithStrategy() {
            stopEverything();
            if (settings.readImmediately) {
                speakWordFlow();
            } else {
                runCountdown(settings.autoDelay, "è©¦ä¸‹è‡ªå·±è®€", () => setTimeout(() => speakWordFlow(), 0));
            }
        }

        async function manualNext() {
            if (words.length === 0) return;
            await unlockAudioAndSpeech();
            if (document.getElementById('randomOrder').checked) currentIndex = pickNextIndexRandom(false);
            else currentIndex = (currentIndex + 1) % words.length;
            updateCard();
            playCardAudioWithStrategy();
        }

        async function manualPrev() {
            if (words.length === 0) return;
            await unlockAudioAndSpeech();
            currentIndex = (currentIndex - 1 + words.length) % words.length;
            updateCard();
            playCardAudioWithStrategy();
        }

        function startSequence() {
            stopEverything(); 
            if (words.length === 0) return;
            if (settings.readImmediately) {
                speakWordFlow();
            } else {
                runCountdown(settings.autoDelay, "è©¦ä¸‹è‡ªå·±è®€", () => setTimeout(() => speakWordFlow(), 0));
            }
        }

        function startRecording() {
            if (words.length === 0 || isRecording) return;
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { alert("ä¸æ”¯æ´éŒ„éŸ³"); return; }
            window.speechSynthesis.cancel(); stopEverything();

            navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                let options = MediaRecorder.isTypeSupported('audio/webm') ? { mimeType: 'audio/webm' } : {};
                try { mediaRecorder = new MediaRecorder(stream, options); } catch (e) { mediaRecorder = new MediaRecorder(stream); }
                audioChunks = [];
                mediaRecorder.ondataavailable = event => { if (event.data.size > 0) audioChunks.push(event.data); };
                mediaRecorder.onstop = () => {
                    const blob = new Blob(audioChunks, { type: mediaRecorder.mimeType || 'audio/webm' });
                    words[currentIndex].audioBlob = blob;
                    showToast("éŒ„éŸ³å·²ä¿å­˜ï¼"); markDirty(); renderLists();
                };
                mediaRecorder.start(); isRecording = true;
                document.getElementById('recordBtn').classList.add('recording');
                recordingSeconds = 0; updateRecordingUI();
                recordingTimerInterval = setInterval(() => { recordingSeconds++; updateRecordingUI(); }, 1000);
            }).catch(() => alert("ç„¡æ³•å­˜å–éº¥å…‹é¢¨"));
        }

        function updateRecordingUI() {
            const badge = document.getElementById('statusBadge');
            badge.textContent = `ğŸ”´ éŒ„éŸ³ä¸­ (${recordingSeconds}s)...`;
            badge.className = 'status-badge status-recording'; badge.style.opacity = '1';
        }

        function stopRecording() {
            if (!isRecording || !mediaRecorder) return;
            mediaRecorder.stop(); isRecording = false;
            clearInterval(recordingTimerInterval);
            document.getElementById('recordBtn').classList.remove('recording');
            if (mediaRecorder.stream) mediaRecorder.stream.getTracks().forEach(track => track.stop());
            updateStatusUI();
        }

        function stopEverything() {
            clearTimeout(state.timerId); clearInterval(state.timerId); clearTimeout(state.watchdogId);
            window.speechSynthesis.cancel(); globalAudioPlayer.pause();
            state.status = 'idle'; state.repeatCount = 0; updateStatusUI();
        }

        async function toggleSpeak() {
            if (words.length === 0) return;
            await unlockAudioAndSpeech();
            if (state.status === 'paused') resumeFlow();
            else if (state.status === 'countdown' || state.status === 'speaking') pauseFlow();
            else { 
                speakWordFlow(); 
            }
        }

        function pauseFlow() { stopEverything(); state.status = 'paused'; updateStatusUI(); }
        function resumeFlow() { if (state.countdownCallback) runCountdown(state.countdownRemaining, state.countdownLabel, state.countdownCallback); else speakWordFlow(); }

        function runCountdown(seconds, text, callback) {
            state.status = 'countdown'; state.countdownRemaining = seconds; state.countdownLabel = text; state.countdownCallback = callback;
            updateStatusUI();
            state.timerId = setInterval(() => {
                state.countdownRemaining--;
                if (state.countdownRemaining > 0) updateStatusUI();
                else { clearInterval(state.timerId); state.countdownCallback = null; callback(); }
            }, 1000);
        }

        function speakWordFlow() {
            if (words.length === 0) return;
            state.status = 'speaking'; updateStatusUI();
            if (state.repeatCount === 0) { words[currentIndex].views++; markDirty(); renderLists(); updateCard(); }
            const item = words[currentIndex];
            playItemAudio(item, () => handleSpeakEnd());
        }

        function playItemAudio(item, onEndCallback) {
            window.speechSynthesis.cancel(); globalAudioPlayer.pause(); globalAudioPlayer.currentTime = 0;
            if (item.audioBlob) {
                const url = URL.createObjectURL(item.audioBlob);
                globalAudioPlayer.src = url; globalAudioPlayer.volume = 1.0;
                globalAudioPlayer.onended = () => { if(onEndCallback) onEndCallback(); URL.revokeObjectURL(url); };
                globalAudioPlayer.play().catch(() => { speakTTS(item.text, onEndCallback); });
            } else {
                speakTTS(item.text, onEndCallback);
            }
        }

        function speakTTS(text, onEndCallback) {
            const u = new SpeechSynthesisUtterance(text);
            if (isEnglish(text)) { u.lang = 'en-IE'; if (englishVoice) u.voice = englishVoice; u.rate = 0.9; }
            else { u.lang = 'zh-HK'; if (cantoneseVoice) u.voice = cantoneseVoice; u.rate = 0.8; }
            u.onend = u.onerror = () => { if(onEndCallback) onEndCallback(); };
            window.speechSynthesis.speak(u);
        }

        function handleSpeakEnd() {
            clearTimeout(state.watchdogId);
            if (state.status === 'paused') return;
            if (document.getElementById('repeatThreeTimes').checked && state.repeatCount < 2) {
                state.repeatCount++;
                runCountdown(settings.repeatDelay, `æº–å‚™å†è®€ (${state.repeatCount}/2)`, () => speakWordFlow());
            } else {
                state.status = 'idle'; state.repeatCount = 0; updateStatusUI();
                if (document.getElementById('autoPlayNext').checked) state.timerId = setTimeout(() => advanceNextForAuto(), 500);
            }
        }

        function updateStatusUI() {
            const badge = document.getElementById('statusBadge');
            const btn = document.getElementById('speakBtn');
            badge.style.opacity = '0';
            if (state.status === 'paused') {
                btn.innerHTML = "â–¶ï¸ ç¹¼çºŒ"; btn.classList.add('paused');
                badge.textContent = `â¸ å·²æš«åœ`; badge.className = 'status-badge status-paused'; badge.style.opacity = '1';
            } else if (state.status === 'countdown') {
                btn.innerHTML = "â¸ æš«åœ"; btn.classList.add('paused');
                badge.textContent = `${state.countdownLabel} (${state.countdownRemaining})`; badge.className = 'status-badge status-waiting'; badge.style.opacity = '1';
            } else if (state.status === 'speaking') {
                btn.innerHTML = "â¸ æš«åœ"; btn.classList.add('paused');
                badge.textContent = 'ğŸ”Š è½ä¸‹è®€éŸ³'; badge.className = 'status-badge status-reading'; badge.style.opacity = '1';
            } else {
                btn.innerHTML = "ğŸ”Š æœ—è®€"; btn.classList.remove('paused');
            }
        }

        function renderLists() {
            const wordList = document.getElementById('wordList');
            const reviewList = document.getElementById('reviewList');
            const mList = document.getElementById('masteredList');
            document.getElementById('wordCount').textContent = `(${words.length})`;
            document.getElementById('reviewCount').textContent = `(${reviewWords.length})`;
            document.getElementById('masteredCount').textContent = `(${masteredWords.length})`;
            wordList.innerHTML = ''; reviewList.innerHTML = ''; mList.innerHTML = '';
            words.forEach((item, index) => {
                const tag = createTag(item, index, 'word');
                if (index === currentIndex && !isWordSelectMode) tag.classList.add('active');
                wordList.appendChild(tag);
            });
            if (!isWordSelectMode) {
                const addBtn = document.createElement('div'); addBtn.className = 'word-tag add-tag'; addBtn.innerHTML = '<span>+</span>';
                addBtn.onclick = () => convertToAddInput(addBtn);
                wordList.appendChild(addBtn);
            }
            reviewWords.forEach((item, index) => reviewList.appendChild(createTag(item, index, 'review')));
            masteredWords.forEach((item, index) => mList.appendChild(createTag(item, index, 'mastered')));
        }

        function createTag(item, index, type) {
            const div = document.createElement('div'); div.className = 'word-tag';
            const pct = Math.min(100, (item.hits / settings.masteryThreshold) * 100);
            const bg = document.createElement('div'); bg.className = 'word-tag-bg'; bg.style.height = `${pct}%`;
            div.appendChild(bg);
            if (item.audioBlob) { const dot = document.createElement('div'); dot.className = 'has-audio-dot'; div.appendChild(dot); }
            const content = document.createElement('div'); content.className = 'word-tag-content';
            const word = item.text;
            if (isEnglish(word)) div.classList.add('is-english');
            const len = word.length;
            if (len <= 2) div.classList.add('len-2'); else if (len === 3) div.classList.add('len-3'); else if (len === 4) div.classList.add('len-4'); else div.classList.add('len-long');
            content.innerHTML = len === 4 && !isEnglish(word) ? `<span><i>${word.substring(0,2)}</i><i>${word.substring(2,4)}</i></span>` : `<span>${word}</span>`;
            div.appendChild(content);
            const viewCount = document.createElement('div'); viewCount.className = 'view-count'; viewCount.textContent = item.views;
            div.appendChild(viewCount);
            handleInteraction(div, index, item, type);
            return div;
        }

        function convertToAddInput(element) {
            element.innerHTML = '';
            const input = document.createElement('input'); input.type = 'text'; input.className = 'grid-input'; input.placeholder = 'è¼¸å…¥';
            element.appendChild(input); input.focus();
            const save = () => {
                const val = input.value.trim();
                if (val) { words.push({ text: val, views: 0, hits: 0, audioBlob: null, roundId: 0 }); markDirty(); renderLists(); updateCard(); }
                else renderLists();
            };
            input.addEventListener('blur', save); input.addEventListener('keydown', (e) => { if (e.key === 'Enter') input.blur(); });
        }

        function handleInteraction(div, index, item, type) {
            let isModeActive = (type === 'word' && isWordSelectMode) || (type === 'review' && isReviewMode) || (type === 'mastered' && isDeleteMode);
            if (isModeActive) {
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox'; checkbox.className = 'select-checkbox'; checkbox.dataset.index = index;
                div.appendChild(checkbox);
                div.onclick = (e) => { if(e.target !== checkbox) checkbox.checked = !checkbox.checked; };
            } else {
                if (type === 'word') {
                    div.onclick = () => { 
                        if (state.status === 'idle' || state.status === 'paused') { 
                            currentIndex = index; updateCard(); 
                            playCardAudioWithStrategy();
                        } 
                    };
                }
                let pressTimer;
                const startPress = () => { 
                    pressTimer = setTimeout(() => {
                        if (type === 'word') enterWordSelectMode(index);
                        if (type === 'review') enterReviewMode(index);
                        if (type === 'mastered') enterDeleteMode(index);
                    }, 600); 
                };
                const cancelPress = () => clearTimeout(pressTimer);
                div.addEventListener('touchstart', startPress); div.addEventListener('touchend', cancelPress);
                div.addEventListener('mousedown', startPress); div.addEventListener('mouseup', cancelPress);
            }
        }

        function enterWordSelectMode(initialIndex) { 
            isWordSelectMode = true; document.body.classList.add('select-mode-active'); 
            document.getElementById('wordSelectControls').style.display = 'flex'; 
            renderLists(); 
            if(initialIndex !== undefined) checkItem(initialIndex, '#wordList');
            showToast("æ‰¹é‡æ¨¡å¼ (è©èªè¡¨)"); 
        }
        function exitWordSelectMode() { isWordSelectMode = false; document.body.classList.remove('select-mode-active'); document.getElementById('wordSelectControls').style.display = 'none'; renderLists(); }

        function enterReviewMode(initialIndex) { 
            isReviewMode = true; document.body.classList.add('review-mode-active'); 
            document.getElementById('reviewControls').style.display = 'flex'; 
            renderLists(); 
            if(initialIndex !== undefined) checkItem(initialIndex, '#reviewList');
            showToast("æ‰¹é‡æ¨¡å¼ (é‚„è¦ç·´)"); 
        }
        function exitReviewMode() { isReviewMode = false; document.body.classList.remove('review-mode-active'); document.getElementById('reviewControls').style.display = 'none'; renderLists(); }

        function enterDeleteMode(initialIndex) { 
            isDeleteMode = true; document.body.classList.add('delete-mode-active'); 
            document.getElementById('deleteControls').style.display = 'flex'; 
            renderLists(); 
            if(initialIndex !== undefined) checkItem(initialIndex, '#masteredList');
            showToast("æ‰¹é‡æ¨¡å¼ (å·²å­¸è­˜)"); 
        }
        function exitDeleteMode() { isDeleteMode = false; document.body.classList.remove('delete-mode-active'); document.getElementById('deleteControls').style.display = 'none'; renderLists(); }

        function checkItem(index, selector) {
            const cb = document.querySelector(`${selector} .select-checkbox[data-index="${index}"]`);
            if(cb) cb.checked = true;
        }

        function getSelectedIndices(selector) {
            return Array.from(document.querySelectorAll(`${selector} .select-checkbox:checked`))
                .map(c => parseInt(c.dataset.index)).sort((a,b) => b-a);
        }

        function confirmBatchMove() {
            const indices = getSelectedIndices('#wordList'); if (!indices.length) return;
            indices.forEach(idx => { masteredWords.push(words[idx]); words.splice(idx, 1); });
            if (currentIndex >= words.length) currentIndex = 0;
            showToast(`å·²ç§»å‹• ${indices.length} å€‹åˆ°å·²å­¸è­˜`); markDirty(); exitWordSelectMode(); updateCard();
        }
        function confirmBatchMoveFromWordsToReview() {
            const indices = getSelectedIndices('#wordList'); if (!indices.length) return;
            indices.forEach(idx => { reviewWords.push(words[idx]); words.splice(idx, 1); });
            if (currentIndex >= words.length) currentIndex = 0;
            showToast(`å·²ç§»å‹• ${indices.length} å€‹åˆ°é‚„è¦ç·´`); markDirty(); exitWordSelectMode(); updateCard();
        }
        function confirmBatchDeleteFromWords() {
            const indices = getSelectedIndices('#wordList'); if (!indices.length) return;
            if(!confirm(`ç¢ºå®šè¦åˆªé™¤é€™ ${indices.length} å€‹è©èªå—ï¼Ÿ`)) return;
            indices.forEach(idx => words.splice(idx, 1));
            if (currentIndex >= words.length) currentIndex = 0;
            showToast(`å·²åˆªé™¤ ${indices.length} å€‹è©èª`); markDirty(); exitWordSelectMode(); updateCard();
        }

        function confirmBatchMoveFromReviewToWords() {
            const indices = getSelectedIndices('#reviewList'); if (!indices.length) return;
            indices.forEach(idx => { let w = reviewWords[idx]; w.views=0; w.hits=0; w.roundId=0; words.push(w); reviewWords.splice(idx, 1); });
            showToast(`å·²é€€å› ${indices.length} å€‹åˆ°è©èªè¡¨`); markDirty(); exitReviewMode(); updateCard();
        }
        function confirmBatchMoveFromReviewToMastered() {
            const indices = getSelectedIndices('#reviewList'); if (!indices.length) return;
            indices.forEach(idx => { masteredWords.push(reviewWords[idx]); reviewWords.splice(idx, 1); });
            showToast(`å·²æ™‰ç´š ${indices.length} å€‹åˆ°å·²å­¸è­˜`); markDirty(); exitReviewMode();
        }
        function confirmBatchDelete() {
            const indices = getSelectedIndices('#masteredList'); if (!indices.length) return;
            indices.forEach(idx => masteredWords.splice(idx, 1));
            showToast(`å·²åˆªé™¤ ${indices.length} å€‹è©èª`); markDirty(); exitDeleteMode();
        }
        function confirmBatchRestore() {
            const indices = getSelectedIndices('#masteredList'); if (!indices.length) return;
            indices.forEach(idx => { let w = masteredWords[idx]; w.views=0; w.hits=0; w.roundId=0; words.push(w); masteredWords.splice(idx, 1); });
            showToast(`å·²é‚„åŸ ${indices.length} å€‹åˆ°è©èªè¡¨`); markDirty(); exitDeleteMode(); updateCard();
        }
        function confirmBatchMoveFromMasteredToReview() {
            const indices = getSelectedIndices('#masteredList'); if (!indices.length) return;
            indices.forEach(idx => { let w = masteredWords[idx]; w.views=0; w.hits=0; reviewWords.push(w); masteredWords.splice(idx, 1); });
            showToast(`å·²ç§»å‹• ${indices.length} å€‹åˆ°é‚„è¦ç·´`); markDirty(); exitDeleteMode();
        }

        function updateCard() {
            const display = document.getElementById('currentWord');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            const viewCountDisplay = document.getElementById('cardViewCount');
            const masteryDisplay = document.getElementById('cardMasteryProgress');
            const isRandom = document.getElementById('randomOrder').checked;

            if (words.length === 0) {
                display.textContent = "åŠ å­—å…ˆï¼"; display.style.fontSize = "3rem"; display.classList.remove('en-font');
                document.getElementById('speakBtn').disabled = true; document.getElementById('recordBtn').disabled = true; document.getElementById('masteredBtn').disabled = true;
                progressFill.style.width = `100%`; progressText.textContent = `å…¨éƒ¨å®Œæˆï¼`;
                viewCountDisplay.textContent = ""; masteryDisplay.textContent = "";
                renderLists(); return;
            }

            if (currentIndex >= words.length) currentIndex = 0;
            document.getElementById('speakBtn').disabled = false; document.getElementById('recordBtn').disabled = false; document.getElementById('masteredBtn').disabled = false;
            const item = words[currentIndex];
            if (isRandom && item.roundId !== currentRoundId) item.roundId = currentRoundId;
            display.textContent = item.text;
            if (isEnglish(item.text)) { display.classList.add('en-font'); display.style.fontSize = item.text.length > 8 ? "4rem" : "6rem"; }
            else { display.classList.remove('en-font'); display.style.fontSize = item.text.length > 3 ? "5rem" : "8rem"; }
            
            if (isRandom) {
                const remainingInRound = words.filter(w => w.roundId !== currentRoundId).length;
                progressFill.style.width = '100%'; progressText.textContent = `éš¨æ©Ÿæ¨¡å¼ (æœ¬è¼ªå‰© ${remainingInRound})`;
            } else {
                const pct = ((currentIndex + 1) / words.length) * 100;
                progressFill.style.width = `${pct}%`; progressText.textContent = `${currentIndex + 1} / ${words.length}`;
            }
            viewCountDisplay.textContent = `ğŸ‘‚ ${item.views}`; masteryDisplay.textContent = `ğŸ¯ ${item.hits}/${settings.masteryThreshold}`;
            renderLists();
        }

        function handleMasteryClick(e) {
            if (words.length === 0) return;
            
            stopEverything();

            const item = words[currentIndex]; item.hits++;
            if (item.hits >= settings.masteryThreshold) {
                words.splice(currentIndex, 1);
                if (item.views > settings.masteryViewLimit) {
                    reviewWords.push(item); showToast(`ğŸ‘ è­˜å’—ï¼Œä½†è¦å¤šç·´ä¸‹ã€Œ${item.text}ã€`);
                } else {
                    masteredWords.push(item); showToast(`ğŸ‰ å¤ªæ£’äº†ï¼è¼•é¬†å­¸è­˜ã€Œ${item.text}ã€`);
                    triggerConfetti(null, null, 1.0);
                }
                if (currentIndex >= words.length) currentIndex = 0;
                markDirty(); renderLists();
                if (words.length > 0) {
                    if (document.getElementById('randomOrder').checked) currentIndex = pickNextIndexRandom(true);
                    updateCard(); 
                    startAutoIfEnabled();
                } else updateCard();
            } else {
                const rect = e.target.getBoundingClientRect();
                triggerConfetti(rect.left + rect.width / 2, rect.top + rect.height / 2, 0.4);
                markDirty(); renderLists(); updateCard(); 
                manualNext();
            }
        }

        // --- Game Mode Logic ---
        async function openGameMode() {
            stopEverything();
            await unlockAudioAndSpeech();
            const totalCards = words.length + reviewWords.length + masteredWords.length;
            if (totalCards === 0) { showToast("è«‹å…ˆåŠ å…¥ä¸€äº›ç”Ÿå­—ï¼"); return; }
            isGameActive = true;
            document.getElementById('gameOverlay').style.display = 'flex';
            generateGameRound();
        }

        function closeGameMode() {
            isGameActive = false;
            document.getElementById('gameOverlay').style.display = 'none';
            stopEverything();
            renderLists(); // Refresh main lists in case of mastery
        }

        function generateGameRound() {
            const grid = document.getElementById('gameGrid');
            grid.innerHTML = '';
            
            // 1. Pick Target (Prioritize Review > Words)
            let targetPool = reviewWords.length > 0 ? reviewWords : words;
            if (targetPool.length === 0) targetPool = masteredWords; // Fallback to mastered if others empty
            
            if (targetPool.length === 0) { closeGameMode(); return; } // Should not happen due to check in openGameMode

            const targetIndex = Math.floor(Math.random() * targetPool.length);
            gameTarget = targetPool[targetIndex];

            // 2. Pick Distractors (9 items)
            let distractors = [];
            let allAvailable = [...reviewWords, ...words, ...masteredWords].filter(w => w !== gameTarget);
            
            // Shuffle available real words
            for (let i = allAvailable.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allAvailable[i], allAvailable[j]] = [allAvailable[j], allAvailable[i]];
            }

            // Fill with real words first
            distractors = allAvailable.slice(0, 9);

            // If not enough, fill with FALLBACK_WORDS
            if (distractors.length < 9) {
                let needed = 9 - distractors.length;
                let fallbackPool = [...FALLBACK_WORDS].filter(w => w !== gameTarget.text && !distractors.some(d => d.text === w));
                // Shuffle fallback
                for (let i = fallbackPool.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [fallbackPool[i], fallbackPool[j]] = [fallbackPool[j], fallbackPool[i]];
                }
                for(let i=0; i<needed; i++) {
                    if (i < fallbackPool.length) {
                        distractors.push({ text: fallbackPool[i], isFallback: true });
                    }
                }
            }

            // 3. Combine and Shuffle
            gameItems = [gameTarget, ...distractors];
            for (let i = gameItems.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [gameItems[i], gameItems[j]] = [gameItems[j], gameItems[i]];
            }

            // 4. Render Grid
            gameItems.forEach(item => {
                const card = document.createElement('div');
                card.className = 'game-card';
                if (isEnglish(item.text)) card.classList.add('is-english');
                card.textContent = item.text;
                card.onclick = () => handleGameCardClick(card, item);
                grid.appendChild(card);
            });

            // 5. Play Audio
            setTimeout(() => playGameAudio(), 500);
        }

        function playGameAudio() {
            if (!isGameActive || !gameTarget) return;
            playItemAudio(gameTarget);
        }

        function handleGameCardClick(cardElement, item) {
            if (cardElement.classList.contains('correct')) return; // Already clicked correctly

            if (item === gameTarget) {
                // Correct!
                cardElement.classList.add('correct');
                triggerConfetti(null, null, 0.6);
                
                // Logic: Increment hits
                if (!item.isFallback) {
                    item.hits++;
                    // Check Mastery
                    if (item.hits >= settings.masteryThreshold) {
                        // Move to Mastered
                        if (reviewWords.includes(item)) {
                            reviewWords.splice(reviewWords.indexOf(item), 1);
                            masteredWords.push(item);
                            showToast(`ğŸ‰ æ­å–œï¼ã€Œ${item.text}ã€å·²å­¸è­˜ï¼`);
                        } else if (words.includes(item)) {
                            words.splice(words.indexOf(item), 1);
                            masteredWords.push(item);
                            showToast(`ğŸ‰ æ­å–œï¼ã€Œ${item.text}ã€å·²å­¸è­˜ï¼`);
                        }
                        markDirty();
                    } else {
                        showToast("ç­”å•±å’—ï¼ç¹¼çºŒåŠ æ²¹ï¼");
                        markDirty();
                    }
                } else {
                    showToast("ç­”å•±å’—ï¼");
                }

                // Next round after delay
                setTimeout(() => {
                    if (isGameActive) generateGameRound();
                }, 1500);

            } else {
                // Wrong!
                cardElement.classList.add('shake');
                setTimeout(() => cardElement.classList.remove('shake'), 500);
                // Play the wrong card's audio for learning
                playItemAudio(item);
            }
        }

        function openSettingsModal() {
            document.getElementById('settingAutoDelay').value = settings.autoDelay;
            document.getElementById('settingRepeatDelay').value = settings.repeatDelay;
            document.getElementById('settingMasteryThreshold').value = settings.masteryThreshold;
            document.getElementById('settingMasteryViewLimit').value = settings.masteryViewLimit;
            document.getElementById('settingsModal').style.display = 'flex';
        }

        function autoSaveSettings() {
            settings.autoDelay = parseInt(document.getElementById('settingAutoDelay').value) || 4;
            settings.repeatDelay = parseInt(document.getElementById('settingRepeatDelay').value) || 3;
            settings.masteryThreshold = parseInt(document.getElementById('settingMasteryThreshold').value) || 2;
            settings.masteryViewLimit = parseInt(document.getElementById('settingMasteryViewLimit').value) || 1;
            settings.readImmediately = document.getElementById('readImmediatelyToggle').checked;
            markDirty(); updateCard(); showToast("è¨­å®šå·²æ›´æ–°");
        }

        let pendingAction = null;
        function confirmAction(actionType) {
            pendingAction = actionType;
            const msgEl = document.getElementById('confirmMessage');
            const btnEl = document.getElementById('confirmBtn');
            document.getElementById('confirmModal').style.display = 'flex';
            if (actionType === 'resetStats') { msgEl.textContent = "ç¢ºå®šè¦å°‡æ‰€æœ‰è©èªçš„è½è®€æ¬¡æ•¸å’Œç†Ÿç·´åº¦æ­¸é›¶å—ï¼Ÿ"; btnEl.className = "modal-btn btn-save"; btnEl.style.background = "#5c6bc0"; }
            else if (actionType === 'resetSettings') { msgEl.textContent = "ç¢ºå®šè¦é‚„åŸè¨­å®šåˆ°åˆå§‹å€¼å—ï¼Ÿ"; btnEl.className = "modal-btn btn-save"; btnEl.style.background = "#78909c"; }
            else if (actionType === 'clearAudio') { msgEl.textContent = "ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰è‡ªè£½éŒ„éŸ³å—ï¼Ÿæ–‡å­—æœƒä¿ç•™ã€‚"; btnEl.className = "modal-btn btn-save"; btnEl.style.background = "#ff9800"; }
            else if (actionType === 'clearAll') { msgEl.textContent = "âš ï¸ è­¦å‘Šï¼šé€™å°‡åˆªé™¤æ‰€æœ‰è©èªã€éŒ„éŸ³å’Œé€²åº¦ï¼Œç„¡æ³•é‚„åŸï¼"; btnEl.className = "modal-btn btn-danger"; btnEl.style.background = "#ef5350"; }
        }

        document.getElementById('confirmBtn').onclick = async () => {
            if (!pendingAction) return;
            if (pendingAction === 'resetStats') {
                [words, reviewWords, masteredWords].forEach(list => list.forEach(w => { w.views = 0; w.hits = 0; }));
                markDirty(); renderLists(); updateCard(); showToast("çµ±è¨ˆå·²é‡ç½®");
            } else if (pendingAction === 'resetSettings') {
                settings = { autoDelay: 4, repeatDelay: 3, masteryThreshold: 2, masteryViewLimit: 1, readImmediately: false };
                openSettingsModal(); markDirty(); showToast("è¨­å®šå·²é‚„åŸ");
            } else if (pendingAction === 'clearAudio') {
                let count = 0; [words, reviewWords, masteredWords].forEach(list => list.forEach(w => { if(w.audioBlob) { w.audioBlob = null; count++; } }));
                markDirty(); renderLists(); updateCard(); showToast(`å·²æ¸…é™¤ ${count} å€‹éŒ„éŸ³`);
            } else if (pendingAction === 'clearAll') {
                words = []; reviewWords = []; masteredWords = [];
                settings = { autoDelay: 4, repeatDelay: 3, masteryThreshold: 2, masteryViewLimit: 1, readImmediately: false };
                localStorage.clear(); 
                if(db) {
                    const transaction = db.transaction(['data'], 'readwrite');
                    const store = transaction.objectStore('data');
                    store.clear();
                }
                setTimeout(() => { window.location.reload(); }, 1000);
                showToast("å·²æ¸…ç©ºæ‰€æœ‰è³‡æ–™ï¼Œæ­£åœ¨é‡å•Ÿ...");
            }
            closeModal('confirmModal'); pendingAction = null;
        };

        function openEditModal() {
            const text = `ã€è©èªè¡¨ã€‘\n${words.map(w=>w.text).join('\n')}\n\nã€é‚„è¦ç·´ã€‘\n${reviewWords.map(w=>w.text).join('\n')}\n\nã€å·²å­¸è­˜ã€‘\n${masteredWords.map(w=>w.text).join('\n')}`;
            document.getElementById('importTextarea').value = text;
            document.getElementById('importModal').style.display = 'flex';
        }

        function selectAllImportText() { document.getElementById('importTextarea').select(); showToast("å·²å…¨é¸ï¼Œè«‹ç›´æ¥è²¼ä¸Š"); }

        function saveEdit() {
            const raw = document.getElementById('importTextarea').value;
            if (!raw.trim()) { closeModal('importModal'); return; }
            let currentSection = 'words';
            const newWords = [], newReview = [], newMastered = [];
            raw.split('\n').forEach(line => {
                line = line.trim(); if (!line) return;
                if (line.includes('ã€è©èªè¡¨ã€‘')) { currentSection = 'words'; return; }
                if (line.includes('ã€é‚„è¦ç·´ã€‘')) { currentSection = 'review'; return; }
                if (line.includes('ã€å·²å­¸è­˜ã€‘')) { currentSection = 'mastered'; return; }
                line.split(/[,ï¼Œ]+/).map(w => w.trim()).filter(w => w).forEach(w => {
                    const obj = { text: w, views: 0, hits: 0, audioBlob: null, roundId: 0 };
                    if (currentSection === 'words') newWords.push(obj);
                    else if (currentSection === 'review') newReview.push(obj);
                    else newMastered.push(obj);
                });
            });
            words = newWords; reviewWords = newReview; masteredWords = newMastered;
            currentRoundId = 1; currentIndex = 0;
            markDirty(); renderLists(); updateCard();
            closeModal('importModal'); showToast("å·²æ›´æ–°åˆ—è¡¨");
        }

        function exportData() {
            const text = `ã€è©èªè¡¨ã€‘\n${words.map(w=>w.text).join('\n')}\n\nã€é‚„è¦ç·´ã€‘\n${reviewWords.map(w=>w.text).join('\n')}\n\nã€å·²å­¸è­˜ã€‘\n${masteredWords.map(w=>w.text).join('\n')}`;
            navigator.clipboard.writeText(text).then(() => showToast("å·²è¤‡è£½æ–‡å­—ï¼")).catch(() => showToast("è¤‡è£½å¤±æ•—"));
        }

        function closeModal(id) { document.getElementById(id).style.display = 'none'; }
        function showToast(msg) { const t = document.getElementById('toast'); t.textContent = msg; t.style.opacity = 1; setTimeout(() => t.style.opacity = 0, 2500); }

        function triggerConfetti(originX, originY, intensity) {
            const canvas = document.getElementById('confetti-canvas'); const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            let particles = []; const colors = ['#f44336', '#2196f3', '#ffeb3b', '#4caf50', '#9c27b0', '#ff9800'];
            for (let i = 0; i < Math.floor(150 * intensity); i++) {
                const isBurst = originX != null;
                particles.push({
                    x: isBurst ? originX : Math.random() * canvas.width, y: isBurst ? originY : Math.random() * canvas.height - canvas.height,
                    w: Math.random() * 10 + 5, h: Math.random() * 5 + 5, color: colors[Math.floor(Math.random() * colors.length)],
                    vy: isBurst ? (Math.random() * -15 - 5) : (Math.random() * 3 + 2), vx: isBurst ? (Math.random() * 10 - 5) : (Math.random() * 2 - 1),
                    gravity: isBurst ? 0.5 : 0, r: Math.random() * 360, vr: Math.random() * 10 - 5
                });
            }
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height); let active = false;
                particles.forEach(p => {
                    p.vy += p.gravity; p.y += p.vy; p.x += p.vx; p.r += p.vr;
                    if (p.y < canvas.height) {
                        active = true; ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.r * Math.PI / 180);
                        ctx.fillStyle = p.color; ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h); ctx.restore();
                    }
                });
                if (active) requestAnimationFrame(animate);
            }
            animate();
        }

        window.onload = init;
    </script>
</body>
</html>
